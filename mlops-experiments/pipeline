pipeline {
    agent any

    environment {
        BASE_TAG = "mlops"
        REGION = "us-east-1"
        AMI_ID = "ami-020cba7c55df1f615"
        SUBNET_ID = "subnet-0bccf87c46ca303ed"
        LAUNCH_TEMPLATE_ID = "lt-0b64c4af9d5f19bd8"
        KEY_NAME = "mlops-proj"
        ec2_USER = "ubuntu"
    }

    stages {
        stage('Generate Unique Tag') {
            steps {
                script {
                    env.RANDOM_SUFFIX = UUID.randomUUID().toString().take(8)
                    env.INSTANCE_TAG = "${BASE_TAG}-${RANDOM_SUFFIX}"
                    env.SG_NAME = "${BASE_TAG}-sg-${RANDOM_SUFFIX}"
                    echo "üîñ Generated tag: ${INSTANCE_TAG}"
                }
            }
        }

        stage('Cleanup Old EC2s & SGs') {
            steps {
                withAWS(region: "${REGION}", credentials: 'aws-jenkins-creds') {
                    script {
                        def old_instances = sh(
                            script: """
                                aws ec2 describe-instances \
                                --region ${REGION} \
                                --filters "Name=tag:Name,Values=${BASE_TAG}-*" "Name=instance-state-name,Values=running" \
                                --query "Reservations[].Instances[].InstanceId" \
                                --output text
                            """,
                            returnStdout: true
                        ).trim()

                        if (old_instances) {
                            echo "üóëÔ∏è Terminating old EC2s: ${old_instances}"
                            sh "aws ec2 terminate-instances --region ${REGION} --instance-ids ${old_instances}"
                            sh "aws ec2 wait instance-terminated --region ${REGION} --instance-ids ${old_instances}"
                        } else {
                            echo "‚úÖ No old instances found."
                        }

                        def old_sgs = sh(
                            script: """
                                aws ec2 describe-security-groups \
                                --region ${REGION} \
                                --query "SecurityGroups[?starts_with(GroupName, '${BASE_TAG}-sg-')].GroupId" \
                                --output text
                            """,
                            returnStdout: true
                        ).trim()

                        if (old_sgs) {
                            for (sg_id in old_sgs.tokenize()) {
                                echo "üõ°Ô∏è Deleting SG: ${sg_id}"
                                sh "aws ec2 delete-security-group --region ${REGION} --group-id ${sg_id} || true"
                            }
                        } else {
                            echo "‚úÖ No old SGs found."
                        }
                    }
                }
            }
        }

        stage('Create Security Group') {
            steps {
                withAWS(region: "${REGION}", credentials: 'aws-jenkins-creds') {
                    script {
                        env.VPC_ID = sh(
                            script: """
                                aws ec2 describe-subnets --region ${REGION} --subnet-ids ${SUBNET_ID} \
                                --query "Subnets[0].VpcId" --output text
                            """, returnStdout: true
                        ).trim()

                        env.SECURITY_GROUP_ID = sh(
                            script: """
                                aws ec2 create-security-group \
                                --region ${REGION} \
                                --group-name ${SG_NAME} \
                                --description "MLOps SG for ${INSTANCE_TAG}" \
                                --vpc-id ${VPC_ID} \
                                --query 'GroupId' \
                                --output text
                            """, returnStdout: true
                        ).trim()

                        echo "‚úÖ SG created: ${SECURITY_GROUP_ID}"

                        sh """
                            aws ec2 authorize-security-group-ingress --region ${REGION} --group-id ${SECURITY_GROUP_ID} \
                            --ip-permissions '[
                                {"IpProtocol": "tcp", "FromPort": 22, "ToPort": 22, "IpRanges": [{"CidrIp": "0.0.0.0/0"}]},
                                {"IpProtocol": "tcp", "FromPort": 80, "ToPort": 80, "IpRanges": [{"CidrIp": "0.0.0.0/0"}]},
                                {"IpProtocol": "tcp", "FromPort": 443, "ToPort": 443, "IpRanges": [{"CidrIp": "0.0.0.0/0"}]},
                                {"IpProtocol": "tcp", "FromPort": 8888, "ToPort": 8888, "IpRanges": [{"CidrIp": "0.0.0.0/0"}]},
                                {"IpProtocol": "tcp", "FromPort": 5000, "ToPort": 5000, "IpRanges": [{"CidrIp": "0.0.0.0/0"}]}
                            ]'
                        """
                    }
                }
            }
        }

        stage('Launch EC2 Instance') {
            steps {
                withAWS(region: "${REGION}", credentials: 'aws-jenkins-creds') {
                    script {
                        echo "üöÄ Launching EC2 instance..."
                        env.INSTANCE_ID = sh(
                            script: """
                                aws ec2 run-instances \
                                --region ${REGION} \
                                --image-id "${AMI_ID}" \
                                --instance-type "t3.large" \
                                --instance-initiated-shutdown-behavior "stop" \
                                --key-name "${KEY_NAME}" \
                                --block-device-mappings '[{
                                    "DeviceName": "/dev/sda1",
                                    "Ebs": {
                                        "DeleteOnTermination": true,
                                        "VolumeSize": 30,
                                        "VolumeType": "gp3"
                                    }
                                }]' \
                                --network-interfaces '[{
                                    "SubnetId": "${SUBNET_ID}",
                                    "DeleteOnTermination": true,
                                    "AssociatePublicIpAddress": true,
                                    "DeviceIndex": 0,
                                    "Groups": ["${SECURITY_GROUP_ID}"]
                                }]' \
                                --launch-template '{"LaunchTemplateId":"${LAUNCH_TEMPLATE_ID}","Version":"1"}' \
                                --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=${INSTANCE_TAG}}]' \
                                --count 1 \
                                --query "Instances[0].InstanceId" \
                                --output text
                            """,
                            returnStdout: true
                        ).trim()

                        echo "‚úÖ Launched instance: ${INSTANCE_ID}"

                        echo "‚è≥ Waiting for instance to be running..."
                        sh "aws ec2 wait instance-running --region ${REGION} --instance-ids ${INSTANCE_ID}"

                        env.INSTANCE_IP = sh(
                            script: """
                                aws ec2 describe-instances \
                                --region ${REGION} \
                                --instance-ids ${INSTANCE_ID} \
                                --query "Reservations[0].Instances[0].PublicIpAddress" \
                                --output text
                            """,
                            returnStdout: true
                        ).trim()

                        echo "üåê Instance public IP: ${INSTANCE_IP}"

                        env.INSTANCE_PRIVATE_IP = sh(
                            script: """
                                aws ec2 describe-instances \
                                --region ${REGION} \
                                --instance-ids ${INSTANCE_ID} \
                                --query "Reservations[0].Instances[0].PrivateIpAddress" \
                                --output text
                            """,
                            returnStdout: true
                        ).trim()

                        echo "Instance private IP: ${INSTANCE_PRIVATE_IP}"
                    }
                }
            }
        }

        stage('SSH Install Docker & Reboot') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Installing Docker on remote EC2..."
                        sh """
                            chmod 400 ${PEM_PATH}
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} << 'EOF'
                                set -e
                                echo "üì¶ Installing Docker..."

                                sudo apt remove -y docker docker-engine docker.io containerd runc || true
                                sudo apt update
                                sudo apt install -y ca-certificates curl gnupg lsb-release

                                sudo mkdir -p /etc/apt/keyrings
                                curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

                                echo "deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

                                sudo apt update
                                sudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

                                sudo systemctl enable docker
                                sudo systemctl start docker

                                sudo groupadd docker || true
                                sudo usermod -aG docker "\$USER"

                                echo "‚úÖ Docker installed. Rebooting..."
                                sudo reboot
                            
                        """ // Ignore failure to keep pipeline alive
                    }
                }
            }
        }

        stage('Wait for Reboot') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "‚åõ Waiting for instance to reboot and become reachable..."
                        retry(10) {
                            sleep(time: 20, unit: 'SECONDS')
                            sh """
                                ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} 'echo "‚úÖ Server is back online!"'
                            """
                        }
                    }
                }
            }
        }

        stage('SSH and Test') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Final SSH check..."
                        sh """
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                echo "‚úÖ Docker Version:"
                                docker --version
                                exit
                            '
                        """
                    }
                }
            }
        }




        stage('SSH and Git Clone') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {

                        env.REPO_DIR="mlops-experiments"

                        echo "üîê Connecting via SSH and cloning Git repository..."
                        sh """
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                set -e
                                
                                REPO_URL="https://github.com/ThatoK3/mlops-experiments.git"
                                

                                if [ ! -d "${REPO_DIR}" ]; then
                                    echo "üì• Cloning repository..."
                                    git clone \$REPO_URL
                                else
                                    echo "‚úÖ Repo already cloned."
                                fi

                                if [ -d "${REPO_DIR}/.git" ]; then
                                    echo "üìÅ Changing to repo directory and verifying..."
                                    cd ${REPO_DIR}
                                    git status
                                else
                                    echo "‚ùå Repository clone failed or invalid."
                                    exit 1
                                fi
                            '
                        """
                    }
                }
            }
        }




        stage('Write .env via SSH') {
            steps {
                withCredentials([
                    file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH'),
                    usernamePassword(credentialsId: 'mlflow-experiments-db-creds', usernameVariable: 'MYSQL_USER', passwordVariable: 'MYSQL_PASSWORD'),
                    usernamePassword(credentialsId: 'mlflow-experiments-db-root-user-creds', usernameVariable: 'MYSQL_ROOT_USER', passwordVariable: 'MYSQL_ROOT_PASSWORD')
                ]) {
                    script {
                        def envContent = """
                            MYSQL_USER=${MYSQL_USER}
                            MYSQL_PASSWORD=${MYSQL_PASSWORD}
                            MYSQL_ROOT_USER=${MYSQL_ROOT_USER}
                            MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
                            MYSQL_HOST=${INSTANCE_PRIVATE_IP}
                            MYSQL_PORT=3306
                            MYSQL_DB=mlflow_db
                        """.stripIndent().trim()

                        sh """
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} 'bash -s' <<EOF
                            cd ${REPO_DIR}
                            cat <<EOT > .env
${envContent}
EOT
                            chmod 600 .env
EOF
                        """
                    }
                }
            }
        }





        stage('SSH and Run Experiments Server') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Connecting via SSH and running experiments server..."
                        sh """
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                set -e

                                cd ${REPO_DIR}

                                sudo bash run_exp_containers.sh
                            '
                        """
                    }
                }
            }
        }


        stage('Check Jupyter Nb Availability') {
            steps {
                script {
                    def SERVICE_NAME = "Jupyter Nb Server" 
                    def PORT = 8888                          
                    def targetUrl = "http://${INSTANCE_IP}:${PORT}/login"

                    echo "üîç Checking if ${SERVICE_NAME} at ${targetUrl} is reachable..."

                    retry(5) {
                        sleep(time: 5, unit: 'SECONDS')
                        sh """
                            STATUS_CODE=\$(curl -o /dev/null -s -w "%{http_code}" --max-time 5 ${targetUrl})
                            if [ "\$STATUS_CODE" != "200" ]; then
                                echo "‚ùå ${SERVICE_NAME} not available yet (HTTP \$STATUS_CODE)"
                                exit 1
                            fi
                            echo "‚úÖ ${SERVICE_NAME} is accessible (HTTP \$STATUS_CODE)"
                        """
                    }
                }
            }
        }


        stage('Check Mlflow Availability') {
            steps {
                script {
                    def SERVICE_NAME = "MLflow Tracking Server" 
                    def PORT = 5000                           
                    def targetUrl = "http://${INSTANCE_IP}:${PORT}"

                    echo "üîç Checking if ${SERVICE_NAME} at ${targetUrl} is reachable..."

                    retry(5) {
                        sleep(time: 5, unit: 'SECONDS')
                        sh """
                            STATUS_CODE=\$(curl -o /dev/null -s -w "%{http_code}" --max-time 5 ${targetUrl})
                            if [ "\$STATUS_CODE" != "200" ]; then
                                echo "‚ùå ${SERVICE_NAME} not available yet (HTTP \$STATUS_CODE)"
                                exit 1
                            fi
                            echo "‚úÖ ${SERVICE_NAME} is accessible (HTTP \$STATUS_CODE)"
                        """
                    }
                }
            }
        }




    }

    post {
        always {
            echo "‚úîÔ∏è Pipeline finished. Instance: ${INSTANCE_ID} | SG: ${SECURITY_GROUP_ID}"
        }
        failure {
            echo "‚ùå Pipeline failed. Check logs above."
        }
    }
}
