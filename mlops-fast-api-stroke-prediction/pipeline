pipeline {
    agent any

    environment {
        BASE_TAG = "mlops-fast-api"
        REGION = "us-east-1"
        AMI_ID = "ami-020cba7c55df1f615"
        SUBNET_ID = "subnet-0bccf87c46ca303ed"
        LAUNCH_TEMPLATE_ID = "lt-0b64c4af9d5f19bd8"
        KEY_NAME = "mlops-proj"
        ec2_USER = "ubuntu"
    }

    stages {
        stage('Generate Unique Tag') {
            steps {
                script {
                    env.RANDOM_SUFFIX = UUID.randomUUID().toString().take(8)
                    env.INSTANCE_TAG = "${BASE_TAG}-${RANDOM_SUFFIX}"
                    env.SG_NAME = "${BASE_TAG}-sg-${RANDOM_SUFFIX}"
                    echo "üîñ Generated tag: ${INSTANCE_TAG}"
                }
            }
        }

        stage('Cleanup Old EC2s & SGs') {
            steps {
                withAWS(region: "${REGION}", credentials: 'aws-jenkins-creds') {
                    script {
                        def old_instances = sh(
                            script: """
                                aws ec2 describe-instances \
                                --region ${REGION} \
                                --filters "Name=tag:Name,Values=${BASE_TAG}-*" "Name=instance-state-name,Values=running" \
                                --query "Reservations[].Instances[].InstanceId" \
                                --output text
                            """,
                            returnStdout: true
                        ).trim()

                        if (old_instances) {
                            echo "üóëÔ∏è Terminating old EC2s: ${old_instances}"
                            sh "aws ec2 terminate-instances --region ${REGION} --instance-ids ${old_instances}"
                            sh "aws ec2 wait instance-terminated --region ${REGION} --instance-ids ${old_instances}"
                        } else {
                            echo "‚úÖ No old instances found."
                        }

                        def old_sgs = sh(
                            script: """
                                aws ec2 describe-security-groups \
                                --region ${REGION} \
                                --query "SecurityGroups[?starts_with(GroupName, '${BASE_TAG}-sg-')].GroupId" \
                                --output text
                            """,
                            returnStdout: true
                        ).trim()

                        if (old_sgs) {
                            for (sg_id in old_sgs.tokenize()) {
                                echo "üõ°Ô∏è Deleting SG: ${sg_id}"
                                sh "aws ec2 delete-security-group --region ${REGION} --group-id ${sg_id} || true"
                            }
                        } else {
                            echo "‚úÖ No old SGs found."
                        }
                    }
                }
            }
        }

        stage('Create Security Group') {
            steps {
                withAWS(region: "${REGION}", credentials: 'aws-jenkins-creds') {
                    script {
                        env.VPC_ID = sh(
                            script: """
                                aws ec2 describe-subnets --region ${REGION} --subnet-ids ${SUBNET_ID} \
                                --query "Subnets[0].VpcId" --output text
                            """, returnStdout: true
                        ).trim()

                        env.SECURITY_GROUP_ID = sh(
                            script: """
                                aws ec2 create-security-group \
                                --region ${REGION} \
                                --group-name ${SG_NAME} \
                                --description "MLOps SG for ${INSTANCE_TAG}" \
                                --vpc-id ${VPC_ID} \
                                --query 'GroupId' \
                                --output text
                            """, returnStdout: true
                        ).trim()

                        echo "‚úÖ SG created: ${SECURITY_GROUP_ID}"

                        sh """
                            aws ec2 authorize-security-group-ingress --region ${REGION} --group-id ${SECURITY_GROUP_ID} \
                            --ip-permissions '[
                                {"IpProtocol": "tcp", "FromPort": 22, "ToPort": 22, "IpRanges": [{"CidrIp": "54.236.64.223/32"}]},
                                {"IpProtocol": "tcp", "FromPort": 22, "ToPort": 22, "IpRanges": [{"CidrIp": "3.93.149.88/32"}]},
                                {"IpProtocol": "tcp", "FromPort": 22, "ToPort": 22, "IpRanges": [{"CidrIp": "44.212.42.254/32"}]},
                                {"IpProtocol": "tcp", "FromPort": 80, "ToPort": 80, "IpRanges": [{"CidrIp": "54.236.64.223/32"}]},
                                {"IpProtocol": "tcp", "FromPort": 443, "ToPort": 443, "IpRanges": [{"CidrIp": "54.236.64.223/32"}]},
                                {"IpProtocol": "tcp", "FromPort": 8000, "ToPort": 8000, "IpRanges": [{"CidrIp": "3.93.149.88/32"}]},
                                {"IpProtocol": "tcp", "FromPort": 8000, "ToPort": 8000, "IpRanges": [{"CidrIp": "44.212.42.254/32"}]},
                                {"IpProtocol": "tcp", "FromPort": 8000, "ToPort": 8000, "IpRanges": [{"CidrIp": "54.236.64.223/32"}]},
                                {"IpProtocol": "tcp", "FromPort": 8000, "ToPort": 8000, "IpRanges": [{"CidrIp": "3.82.125.25/32"}]},
                                {"IpProtocol": "tcp", "FromPort": 9090, "ToPort": 9090, "IpRanges": [{"CidrIp": "3.91.20.155/32",  "Description": "Access from grafana monitoring server"}]}
                            ]'
                        """
                    }
                }
            }
        }

        stage('Launch EC2 Instance') {
            steps {
                withAWS(region: "${REGION}", credentials: 'aws-jenkins-creds') {
                    script {
                        echo "üöÄ Launching EC2 instance..."
                        env.INSTANCE_ID = sh(
                            script: """
                                aws ec2 run-instances \
                                --region ${REGION} \
                                --image-id "${AMI_ID}" \
                                --instance-type "t3.large" \
                                --instance-initiated-shutdown-behavior "stop" \
                                --key-name "${KEY_NAME}" \
                                --block-device-mappings '[{
                                    "DeviceName": "/dev/sda1",
                                    "Ebs": {
                                        "DeleteOnTermination": true,
                                        "VolumeSize": 30,
                                        "VolumeType": "gp3"
                                    }
                                }]' \
                                --network-interfaces '[{
                                    "SubnetId": "${SUBNET_ID}",
                                    "DeleteOnTermination": true,
                                    "AssociatePublicIpAddress": true,
                                    "DeviceIndex": 0,
                                    "Groups": ["${SECURITY_GROUP_ID}"]
                                }]' \
                                --launch-template '{"LaunchTemplateId":"${LAUNCH_TEMPLATE_ID}","Version":"1"}' \
                                --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=${INSTANCE_TAG}}]' \
                                --count 1 \
                                --query "Instances[0].InstanceId" \
                                --output text
                            """,
                            returnStdout: true
                        ).trim()

                        echo "‚úÖ Launched instance: ${INSTANCE_ID}"

                        echo "‚è≥ Waiting for instance to be running..."
                        sh "aws ec2 wait instance-running --region ${REGION} --instance-ids ${INSTANCE_ID}"

                        env.INSTANCE_IP = sh(
                            script: """
                                aws ec2 describe-instances \
                                --region ${REGION} \
                                --instance-ids ${INSTANCE_ID} \
                                --query "Reservations[0].Instances[0].PublicIpAddress" \
                                --output text
                            """,
                            returnStdout: true
                        ).trim()

                        echo "üåê Instance public IP: ${INSTANCE_IP}"

                        env.INSTANCE_PRIVATE_IP = sh(
                            script: """
                                aws ec2 describe-instances \
                                --region ${REGION} \
                                --instance-ids ${INSTANCE_ID} \
                                --query "Reservations[0].Instances[0].PrivateIpAddress" \
                                --output text
                            """,
                            returnStdout: true
                        ).trim()

                        echo "Instance private IP: ${INSTANCE_PRIVATE_IP}"
                    }
                }
            }
        }

        stage('SSH Install Docker & Reboot') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Installing Docker on remote EC2..."
                        retry(5) {
                            sleep 10
                            sh """
                                ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} << 'EOF'
                                    set -e
                                    echo "üì¶ Installing Docker..."

                                    sudo apt remove -y docker docker-engine docker.io containerd runc || true
                                    sudo apt update
                                    sudo apt install -y ca-certificates curl gnupg lsb-release

                                    sudo mkdir -p /etc/apt/keyrings
                                    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

                                    echo "deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

                                    sudo apt update
                                    sudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

                                    sudo systemctl enable docker
                                    sudo systemctl start docker

                                    sudo groupadd docker || true
                                    sudo usermod -aG docker "\$USER"

                                    echo "‚úÖ Docker installed. Rebooting..."
                                    sudo reboot
EOF
                            """
                        }
                    }
                }
            }
        }

        stage('Wait for Reboot') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "‚åõ Waiting for instance to reboot and become reachable..."
                        retry(10) {
                            sleep 20
                            sh """
                                ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} 'echo "‚úÖ Server is back online!"'
                            """
                        }
                    }
                }
            }
        }

        stage('SSH and Test') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Final SSH check..."
                        sh """
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                echo "‚úÖ Docker Version:"
                                docker --version
                            '
                        """
                    }
                }
            }
        }

        stage('Install mysql client') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Installing mysql-client on remote EC2..."
                        sh """
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} << 'EOF'
                                set -e
                                echo "üì¶ Installing mysql-client..."
                                sudo apt install mysql-client -y
EOF
                        """
                    }
                }
            }
        }

        stage('Prometheus & Node Exporter installation') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        env.REPO_DIR="grafana-prometheus-server-monitoring"
                        echo "üîê Connecting via SSH and cloning Git repository..."
                        sh """
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                set -e
                                
                                REPO_URL="https://github.com/ThatoK3/grafana-prometheus-server-monitoring.git"
                                
                                if [ ! -d "${REPO_DIR}" ]; then
                                    echo "üì• Cloning repository..."
                                    git clone \$REPO_URL
                                else
                                    echo "‚úÖ Repo already cloned."
                                fi

                                if [ -d "${REPO_DIR}/.git" ]; then
                                    echo "üìÅ Changing to repo directory, verifying and installing Prometheus..."
                                    cd ${REPO_DIR}
                                    git status
                                    sudo bash install_prometheus.sh
                                else
                                    echo "‚ùå Repository clone failed or installation invalid."
                                    exit 1
                                fi
                            '
                        """
                    }
                }
            }
        }

        stage('Clone MLOps Fast API Repo') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        env.REPO_DIR="mlops-fast-api-prod"
                        echo "üîê Connecting via SSH and cloning Git repository..."
                        sh """
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                set -e
                                
                                REPO_URL="https://github.com/ThatoK3/mlops-fast-api-prod.git"
                                
                                if [ ! -d "${REPO_DIR}" ]; then
                                    echo "üì• Cloning repository..."
                                    git clone \$REPO_URL
                                else
                                    echo "‚úÖ Repo already cloned."
                                fi

                                if [ -d "${REPO_DIR}/.git" ]; then
                                    echo "üìÅ Changing to repo directory and verifying..."
                                    cd ${REPO_DIR}
                                    git status
                                else
                                    echo "‚ùå Repository clone failed or invalid."
                                    exit 1
                                fi
                            '
                        """
                    }
                }
            }
        }

        stage('Write .env via SSH') {
            steps {
                withCredentials([
                    file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH'),
                    usernamePassword(credentialsId: 'mlflow-experiments-db-creds', usernameVariable: 'MYSQL_USER', passwordVariable: 'MYSQL_PASSWORD'),
                    usernamePassword(credentialsId: 'mlflow-experiments-db-root-user-creds', usernameVariable: 'MYSQL_ROOT_USER', passwordVariable: 'MYSQL_ROOT_PASSWORD'),
                    usernamePassword(credentialsId: 'aws-mssql-db-stroke-pred-api-v1', usernameVariable: 'MSSQL_USER', passwordVariable: 'MSSQL_PASSWORD')
                ]) {
                    withAWS(region: 'us-east-1', credentials: 'aws-jenkins-creds') {
                        script {
                            def awsAccessKey = env.AWS_ACCESS_KEY_ID ?: ''
                            def awsSecretKey = env.AWS_SECRET_ACCESS_KEY ?: ''
                            
                            def envContent = """
# MySQL
MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
MYSQL_USER=${MYSQL_USER}
MYSQL_PASSWORD=${MYSQL_PASSWORD}
MYSQL_HOST=mysql
MYSQL_PORT=3306
MYSQL_DATABASE=stroke_predictions
MYSQL_SERVER_ID=184054
MYSQL_SERVER_NAME=dbserver1

# MSSQL
MSSQL_HOST=stroke-pred-api-v1.c0lswie66uam.us-east-1.rds.amazonaws.com
MSSQL_PORT=1433
MSSQL_DB=stroke_predictions_sink
MSSQL_USER=${MSSQL_USER}
MSSQL_PASSWORD="${MSSQL_PASSWORD}"

# AWS creds
AWS_ACCESS_KEY_ID=${awsAccessKey}
AWS_SECRET_ACCESS_KEY=${awsSecretKey}
AWS_DEFAULT_REGION=us-east-1
AWS_REGION=us-east-1
SCHEMA_REGISTRY_URL=http://schema-registry:8081
S3_BUCKET=mlops-dbz-sink

# Paths (relative to project root)
JDBC_SINK_JARS=./kconnect-jdbc-sink-jars
S3_SINK_JARS=./kconnect-s3-sink-jars
CONNECT_TRANSFORMS=./confluentic-connect-transforms
FAST_API=./fast_api
MODELS=./models
NOTEBOOKS=./notebooks
SAVED_MODEL=./models/Logistic_Regression.pkl

INSTANCE_PRIVATE_IP=${INSTANCE_PRIVATE_IP}
""".stripIndent().trim()

                            sh """
                                ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} 'bash -s' <<EOF
                                cd ${REPO_DIR}
                                cat > .env <<EOT
${envContent}
EOT
                                chmod 600 .env
EOF
                            """
                        }
                    }
                }
            }
        }

        stage('SSH and Run docker compose') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Connecting via SSH and docker compose..."
                        retry(3) {
                            sleep 10
                            sh """
                                ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                    set -e
                                    cd ${REPO_DIR}
                                    docker compose down
                                    docker compose --env-file .env up -d --build
                                '
                            """
                        }
                    }
                }
            }
        }

        stage('SSH and Run upload db data') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Connecting via SSH and uploading db data..."
                        retry(10) {
                            sleep 45
                            sh """
                                ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                    cd ${REPO_DIR}
                                    bash upload_db_data.sh
                                '
                            """
                        }
                    }
                }
            }
        }

        stage('SSH and Run register mysql source db connector') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Connecting via SSH and registering mysql source db data to kafta..."
                        retry(3) {
                            sleep 10
                            sh """
                                ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                    set -e
                                    cd ${REPO_DIR}
                                    bash dbz-register-mysql-source.sh

                                    sleep 30
                                    curl -s http://localhost:8083/connectors/stroke-predictions-connector/status | jq
                                '
                            """
                        }
                    }
                }
            }
        }

        stage('SSH and Run register mssql sink db connector') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Connecting via SSH and registering mssql sink db connector to kafta..."
                        retry(3) {
                            sleep 10
                            sh """
                                ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                    set -e
                                    cd ${REPO_DIR}
                                    bash dbz-register-mssql-sink.sh

                                    sleep 30
                                    curl -s http://localhost:8083/connectors/mssql-sink-predictions/status | jq
                                '
                            """
                        }
                    }
                }
            }
        }

        stage('SSH and Run register s3 topics sink connector') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîê Connecting via SSH and registering s3 topics sink connector..."
                        retry(3) {
                            sleep 10
                            sh """
                                ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                    cd ${REPO_DIR}
                                    source .env
                                    bash dbz-register-s3-sink.sh

                                    sleep 30
                                    curl -s http://localhost:8083/connectors/s3-sink-stroke-predictions/status | jq
                                '
                            """
                        }
                    }
                }
            }
        }

        stage('Check fast api Availability') {
            steps {
                script {
                    def SERVICE_NAME = "Fast API" 
                    def PORT = 8000                          
                    def targetUrl = "http://${INSTANCE_IP}:${PORT}"

                    echo "üîç Checking if ${SERVICE_NAME} at ${targetUrl} is reachable..."

                    retry(10) {
                        sleep 45
                        sh """
                            STATUS_CODE=\$(curl -o /dev/null -s -w "%{http_code}" --max-time 5 ${targetUrl})
                            if [ "\$STATUS_CODE" != "200" ]; then
                                echo "‚ùå ${SERVICE_NAME} not available yet (HTTP \$STATUS_CODE)"
                                exit 1
                            fi
                            echo "‚úÖ ${SERVICE_NAME} is accessible (HTTP \$STATUS_CODE)"
                        """
                    }
                }
            }
        }



        stage('Configure Prometheus for Kafka Connect Monitoring') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîß Configuring Prometheus for Kafka Connect CDC monitoring..."
                        sh """
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                set -e
                                
                                echo "üì¶ Creating backup of current Prometheus config..."
                                sudo cp /etc/prometheus/prometheus.yml /etc/prometheus/prometheus.yml.backup.\$(date +%Y%m%d_%H%M%S)
                                
                                echo "üîÑ Updating Prometheus configuration for Kafka Connect..."
                                cat > /tmp/prometheus_new.yml << \\EOF
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: prometheus
    static_configs:
      - targets: ['localhost:9090']

  - job_name: node
    static_configs:
      - targets: ['localhost:9100']

  # Kafka Connect CDC Metrics (Debezium) - PORT 9400
  - job_name: 'kafka-connect-cdc'
    scrape_interval: 15s
    static_configs:
      - targets: ['localhost:9400']
        labels:
          environment: 'production'
          service: 'debezium-cdc'
          host: 'cdc-server'

EOF

                                echo "‚úÖ Validating new configuration..."
                                if ! sudo promtool check config /tmp/prometheus_new.yml; then
                                    echo "‚ùå Configuration validation failed!"
                                    exit 1
                                fi

                                echo "üì§ Applying new configuration..."
                                sudo mv /tmp/prometheus_new.yml /etc/prometheus/prometheus.yml
                                sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml
                                sudo chmod 644 /etc/prometheus/prometheus.yml

                                echo "üîÑ Reloading Prometheus..."
                                if sudo systemctl reload prometheus 2>/dev/null; then
                                    echo "‚úÖ Prometheus reloaded via systemctl"
                                elif curl -X POST http://localhost:9090/-/reload 2>/dev/null; then
                                    echo "‚úÖ Prometheus reloaded via HTTP API"
                                else
                                    echo "‚ö†Ô∏è  Reload failed, restarting Prometheus..."
                                    sudo systemctl restart prometheus
                                fi

                                echo "üéâ Prometheus configuration updated for Kafka Connect CDC!"
                                echo "üìä Metrics available at: http://localhost:9090/targets"
                            '
                        """
                    }
                }
            }
        }




        stage('Verify Monitoring Setup') {
            steps {
                withCredentials([file(credentialsId: 'mlops-ssh-key', variable: 'PEM_PATH')]) {
                    script {
                        echo "üîç Verifying monitoring setup..."
                        sh """
                            ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${ec2_USER}@${INSTANCE_IP} '
                                set -e
                                
                                echo "üìã Checking Prometheus targets..."
                                echo "----------------------------------------"
                                curl -s http://localhost:9090/api/v1/targets | jq -r \'.data.activeTargets[] | .scrapeUrl + " - " + .health\'
                                
                                echo ""
                                echo "üìä Checking Kafka Connect metrics..."
                                echo "----------------------------------------"
                                CONNECT_METRICS=\$(curl -s http://localhost:9400/metrics | head -20)
                                if echo "\$CONNECT_METRICS" | grep -q "kafka_connect"; then
                                    echo "‚úÖ Kafka Connect metrics found!"
                                    echo "\$CONNECT_METRICS" | grep "kafka_connect" | head -5
                                else
                                    echo "‚ùå No Kafka Connect metrics found on port 9400"
                                    exit 1
                                fi
                                
                                echo ""
                                echo "üéØ Monitoring endpoints:"
                                echo "----------------------------------------"
                                echo "Prometheus UI:    http://${INSTANCE_IP}:9090"
                                echo "Grafana UI:       http://grafanaip:3000"
                                echo "Connect Metrics:  http://${INSTANCE_IP}:9400/metrics"
                            '
                        """
                    }
                }
            }
        }



    }

    post {
        always {
            echo "‚úîÔ∏è Pipeline finished. Instance: ${INSTANCE_ID} | SG: ${SECURITY_GROUP_ID}"
        }
        failure {
            echo "‚ùå Pipeline failed. Check logs above."
        }
    }
}
